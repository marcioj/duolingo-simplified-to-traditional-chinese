{"version":3,"sources":["characters.js","cache.js","characterLookup.js","../../node_modules/sizzle/dist/sizzle.js","duolingo.js","mutationObserver.js","main.js"],"names":["simpChars","tradChars","charactersNoDef","i","length","push","charAt","charactersWithDef","split","characters","concat","charactersVersion","Cache","simplifiedCharacter","realCharacter","localStorage","setItem","getItem","parseFloat","clear","console","log","forEach","x","simplified","traditional","CharacterLookup","dictionary","meaning","type","explaination","character","characterLookup","configuration","settingsChanged","document","body","classList","add","remove","chrome","storage","sync","get","result","meanings","onChanged","addListener","changes","Object","keys","newValue","Duolingo","state","JSON","parse","user","courseId","match","maoCharacacter","setTimeout","singleChalengeElement","querySelector","childElementCount","getMeaning","undefined","div","createElement","englishTranslation","innerHTML","appendChild","element","slice","replace","isLearningChinese","y","insertCharacter","mutationObserver","MutationObserver","mutations","j","node","addedNodes","nodeSting","textContent","asciiStringArray","difference","filter","indexOf","chineseCharacters","compoundChineseCharacters","lastCharacterChinese","lastCharacter","compoundCharacter","unshift","characterEncoded","encodeURI","reqListener","data","currentTarget","responseText","setCharacter","navigator","onLine","updateLocalStorage","checkForChineseCharactersOnLoad","observe","childList","subtree","characterData"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAIA,SAAS,GAAG,mjFAAhB;AAEA,IAAIC,SAAS,GAAG,mjFAAhB;AAEA,IAAIC,eAAe,GAAG,EAAtB;;AAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACI,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzCD,EAAAA,eAAe,CAACG,IAAhB,CAAqBL,SAAS,CAACM,MAAV,CAAiBH,CAAjB,IAAoB,GAApB,GAAwBF,SAAS,CAACK,MAAV,CAAiBH,CAAjB,CAA7C;AACD;;AAED,IAAII,iBAAiB,GAAG,86lBAkwBnBC,KAlwBmB,CAkwBb,IAlwBa,CAAxB;AAowBO,IAAMC,UAAU,GAAGP,eAAe,CAACQ,MAAhB,CAAuBH,iBAAvB,CAAnB;;AAEA,IAAMI,iBAAiB,GAAG,GAA1B;;;;;;;;;;AChxBP;;;;;;;;;;;;;;;;IAEaC;;;;;;;;;iCACUC,qBAAqBC,eAAc;AACrDC,MAAAA,YAAY,CAACC,OAAb,CAAqBH,mBAArB,EAA0CC,aAA1C;AACD;;;yCACyB;AAEzB,UAAIC,YAAY,CAACE,OAAb,CAAqB,SAArB,KAAmC,IAAnC,IAA2CC,UAAU,CAACH,YAAY,CAACE,OAAb,CAAqB,SAArB,CAAD,CAAV,GAA8CN,6BAA7F,EAA+G;AAC7GI,QAAAA,YAAY,CAACI,KAAb;AACAC,QAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ;AACAN,QAAAA,YAAY,CAACC,OAAb,CAAqB,SAArB,EAAgCL,6BAAhC;;AACAF,+BAAWa,OAAX,CAAmB,UAACC,CAAD,EAAO;AAAA,yBACQA,CAAC,CAACf,KAAF,CAAQ,GAAR,CADR;AAAA;AAAA,cACnBgB,UADmB;AAAA,cACPC,WADO;;AAExBV,UAAAA,YAAY,CAACC,OAAb,CAAqBQ,UAArB,EAAiCC,WAAjC;AACD,SAHD;AAID;AACF;;;;;;;;;;;;;;;ACjBH;;;;;;;;;;;;;;;;IACaC;;;AACP,6BAAa;AAAA;;AACX,SAAKC,UAAL,GAAgB,EAAhB;;AACA,SAAI,IAAIJ,CAAR,IAAad,sBAAb,EAAwB;AAAA,gCACyCA,uBAAWc,CAAX,EAAcf,KAAd,CAAoB,GAApB,CADzC;AAAA;AAAA,UACfgB,UADe;AAAA,UACHC,WADG;AAAA,UACUG,OADV;AAAA,UACmBC,IADnB;AAAA,UACyBC,YADzB;;AAEpB,WAAKH,UAAL,CAAgBH,UAAhB,IAA8B;AAACI,QAAAA,OAAO,EAAEA,OAAV;AAAmBC,QAAAA,IAAI,EAACA,IAAxB;AAA8BC,QAAAA,YAAY,EAAEA;AAA5C,OAA9B;AACA,WAAKH,UAAL,CAAgBF,WAAhB,IAAgC;AAACG,QAAAA,OAAO,EAACA,OAAT;AAAkBC,QAAAA,IAAI,EAAEA,IAAxB;AAA8BC,QAAAA,YAAY,EAAGA;AAA7C,OAAhC;AACH;AACF;;;;+BAEUC,WAAU;AAEjB,aAAO,KAAKJ,UAAL,CAAgBI,SAAhB,CAAP;AACH;;;;;;;;;ACdP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChuEA;;AACA;;AACA;;;;;;;;;;;;;;;;;;AACA,IAAIC,eAAe,GAAG,IAAIN,g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","file":"main.map","sourceRoot":"../js","sourcesContent":["var simpChars = '梦缘丢并采乱亘亚亸来仑侣俣侠伥俩仓个们伦伟侧侦伪杰伧伞备佣传伛债伤倾偻仅佥侨仆侥偾雇价仪侬亿当侩俭傧俦侪尽偿优储俪罗攒傩傥俨凶兑儿兖内两册涂冻凛渎处凯凭别删刬刭则刚剥剐剀创铲划剧刘刽刿剑剂劲动务勚勋胜劳势绩劢励劝匀匦汇匮奁椟区协却厍厅厕厌厂厉厣参叆叇丛吴吕呙员呗吣唝唡问启哑衔啰啴唤丧乔单哟呛啬吗呜唢哔叹喽呕啧尝唛哗唠啸叽哓呒咴嘘咝哒哝哕嗳哙喷吨咛吓哜噜啮呖咙响喾严嘤啭嗫冁呓苏嘱国囵围园圆图团垧垯垱埯坝垭执坚垩垴埚阶尧报场塆块茔垲埘坞埙尘堑砖垫坠硗堕坛坟墙垦压垒圹垆坏垄坜壮壸壶寿够夹奂奥夺奋妆姗奸侄娱妩娄妇娅婳娲妫媪妈袅妪娴娆婵娇嫱嫒嬷嫔婴婶懒娈孙学孪宫寝实宁审写宽宠宝将专寻对导尴屃届尸屉屡层屦属冈峃峣岘岛峡崄崃岗岽峥嵛岚岁嵚嵝崭岖崂峤峄岙嵘岭屿岿峦巅巯卺帅师帐带帧帏帼帻帜币帮帱襕干几库庼厢厦荫厨厮庙庑废广廪庐弪张强弹弥弯彟彦雕径从徕复征彻恒悦怅闷凄恼恽恻爱惬悫怆恺忾态愠惨惭恸惯怄怂慭虑悭慑庆忧惫怜愦惮愤悯怃宪忆恳应怿懔恹怼懑惩怀悬忏惧欢恋戆戋戗戬戏战户抛挜挦挟扪扫抡挣挂拣扬换挥构揿损摇捣抢掴掼搂挚抠抟掺捞撑挠挢掸拨抚扑挞挝捡拥掳择击挡担携据挤举拟摈拧搁掷扩撷摆擞撸扰摅撵拢拦撄搀撺摄挛摊搅揽叙败敌数驱敛毙斓斩断旸昽时晋昼晕晖畅暂昵晔昙晓暧旷叠晒书会胧东栅杆栀枧条枭梼梾弃枨枣栋栈桊栖桠杨枫桢业极杩荣桤盘枪杠槚椠椁桨规桩乐枞楼标枢样朴树桦桡桥机椭横槔檩柽档桧检樯槟柠槛苘柜橹榈栉橼栎橱槠栌枥橥榇栊榉棂樱栏权椤栾榄钦欧欤归殁残殒殇殚殓殡歼杀壳毁殴医绒毵牦毡氇气氢氩氲凼决冱没冲沨沵况泄汹浉浐浕浃泾涢凉泪渌净凌沦渊涞浅涣减涡测浑凑浈愍涌汤溇沩准沟温湿沧灭涤荥滪沪滞渗卤浒滚满渔沤汉涟渍涨溆渐浆颍泼洁潜润浔溃滗涠涩浇涝涧渑泽泶浍淀浊浓泞济涛滥潍滨阔溅泺滤滢泻渖浏濒泸沥潇潆潴泷濑潋澜沣滠洒漓滩灏湾滦滟灾为乌烃无煅辉炼炜烟茕焕烦炀荧炝热颎炽烨焰灯炖烧烫焖营灿烛烩熏烬焘耀烁炉烂争爷尔床笺闸牍牵荦犊牺状狝狭狈狰犹狲犸呆狱狮奖独狯猃狞获猎犷兽獭献猕猡兹玙玚珏玱珰现琎珲珉玮琐瑶莹玛琏玑瑷环玺琼珑璎瓒瓯罂产亩毕画异畴痉痖瘆疯疡痪瘗疮疟瘘疗痨痫瘅疠瘪痴痒疖症疬癞癣瘿瘾痈瘫癫发皑皲皱蔼碍袄罢颁办绊绑镑谤盗盏监卢荡视眬众睁饱鲍辈贝钡绷笔闭边编贬变辩辫鳖宾饼睐眍瞒睑瞩钵铂驳补财蚕苍舱诧蝉馋谗缠阐颤矫硁硙硚硖砗砚碜长肠钞车陈衬称诚骋迟驰齿虫踌筹绸丑锄雏硕砀砜确码碛矶础触闯锤纯绰辞词赐聪葱蹿窜错达贷矿砺砾矾砻祎禄祸祯郸胆诞党祷邓递缔颠点电钓调谍御禅礼祢秃秾税秆棱钉顶锭订斗读赌镀锻缎队顿钝鹅额讹饿饵禀种谷稣积颖穑秽颓稳稆贰罚阀钒范贩饭访纺飞诽费纷粪丰锋风冯缝讽凤肤辐窝洼穷窑窭窥窍窦窃竖竞辅赋负讣缚该钙盖赶赣钢纲镐鸽阁铬给笋筜笕筝箓节龚巩贡钩购蛊顾关观馆贯龟闺轨诡贵辊锅过筑箧筱笃筛筚箦篓蓑箪简篑箫檐签帘骇韩号阂鹤贺轰鸿红后篮藤箨籁笼钥笾簖篱箩吁粤护华话还缓黄谎贿讳诲绘荤伙货糁模粮粝籴粜纠纪纣约纡纥纨纫纹纳纽纾纰纼纱纮纸级纭纴细绂绁绅纻饥迹讥鸡缉辑蓟计记际继荚颊贾钾驾间艰缄茧荐鉴践贱见键绍绀绋绐绌终组绗结绝绦绔绞络绚绖统丝绛绢绡绠绨绣绤绥经舰饯蒋讲酱胶骄铰脚饺缴轿较诫紧锦谨进综缍绿绻绶维绹绾网缀纶绺绮绽绫绵绲缁绯缗绪绬绱缃缂缌缅纬缑缈练缏缇荆茎鲸惊颈静镜旧驹锯鹃觉诀钧军缊总萦缙缢缒绉缣缞缜缟缛县缡缩纵缧纤缦絷缕缥缫缪襁缯织缮缭骏开颗课裤夸亏绕缋绳缰缳缲绎缤缱颣缬纩续缨缵缆馈蜡腊莱赖蓝阑兰谰览镭类离鲤丽骂罴羁芈羟羡义习翙翚隶联莲连镰脸链辆谅辽镣临邻鳞赁龄铃灵领馏龙聋翘翱耧耢圣闻声耸聩聂职聍听陇芦颅虏鲁赂录陆驴铝轮论萝逻锣骡骆蚂马买麦卖迈脉馒蛮肃胁胫脱胀谩猫锚铆贸么镁门锰谜觅闽鸣铭谬肾胨腘脶脑肿肷腽腻脍脓脐膑癯谋钠难闹馁酿鸟镊镍胪臜脏脔卧皋与兴铺舣钮农诺鸥庞赔鹏舻艳艹刍苎骗飘频贫苹评颇谱齐骑岂讫荙庄苋钎铅迁谦钱钳谴蔷锹亲轻顷请趋躯苌萚万莴叶荭荮苇药龋颧鹊让饶韧认软锐闰萨鳃赛莼莳荪莜苁荜骚闪陕赡赏赊设蒌茑荨蒇荞荬芸莸荛蒉芜萧蓣诗蚀识驶适释饰试输赎术荟芗姜莶荠荩艺薮苈双谁顺说饲颂讼诵诉虽随锁蔺蕲蕴藓蔹茏蓠虚贪谭谈讨腾誊锑题体贴铁蛱蜕蚬铜头鸵驮驼袜顽猬虾虱蜗螀蛳蚁萤韦违谓卫钨诬雾误锡蝼蛰蝈螨蟏虮蛲蛏蝇虿蝎蛴蝾蛎袭铣辖锨鲜咸贤闲显险馅镶乡详响项销蔑袆衮谐谢锌衅锈须许轩袯裈装裢选询驯训讯逊鸦鸭讶阉盐颜阎谚验鸯阳养褛亵幞裥杂裣裆褴觃觇觋遥谣页铱颐遗诣议谊译阴银饮隐觍觎觊觏觑觐觌觞觯讠讧讦讱讪鹰赢踊咏邮铀诱舆鱼语誉讷谌讻诃诊注证诂诋讵诈诒诏诐诇诎诅詟诩诟诠诘诜诙诖预驭鸳辕远愿跃阅云郧陨运酝韵载赞赃凿责贼赠轧诔诛诓诳诶诮诰谇谄谆诿诤诹诼谂谀谞谝谥诨铡斋辗账赵辙锗这贞针镇阵谔谛谏谕谙诸谖谒诌谧谑谡谟谪讴郑质钟轴骤猪着贮铸谲谮谯谵诪谫雠谶谠谳驻转赚锥赘资踪邹钻豮狸贠鼗靥赝赜贳赀贶贻贲赅赈赇赒赉赓赕赍赆赗赙贽赟黉凫赑赪趱陉陧邝邬邺跶蜷跄跸跖蹒郏郐郄郓郦跷趸跻踯跞踬蹰跹蹑躜躏轪轫轭轷轸轱轵轺轲轶轼辂辁辀轾辄辎辋辍辇辌辏辒毂莺蓦蓥辘辚辔轹轳迩逦酦酾酽钆钇钌钊钋钐狍钏钗钍钕钯钫钘钭钚钤钣钑钬钛钪铌铈钶钴钹铍钰钸钿饧饨饩饪饫饬饴饷饽余馄馇馊馍馐馑馓馔馕铊铉铋钷钺钲钼钽锎铏铒铪铳铚铨铢铫铦铑铷铟闩闫闱闳闵闶闼闾阃阄阆阈阊阋阌阍阏阒阕阖阗阙阚丬铵铥铕铯铐铞锉镅锒铤铗铻镯锊锓铘锃锔锇铓铖锆锂铽锍锞锖锫锩铔锕锟锱铮锛锬锜锠锢铼镎锝锪钔锴锳锷钖锽锸锲锘骞锾锶锿镕镉镈镃镏铠铩锼镒镋镓镌镞镟镆镙驵驷驸驺驿驽骀骁骅骈骊骐骒骓骖骘骛骜骝骟骠骢骣骥骧纟镠镝铿锵镗镘镛镖镂錾镚铧镤镪铙铴铹镦镡镫镢镨锏镄顼镮铎铛镱镬镔镲锧镴铄镳镥镧镵镩銮韪韫韬闬阇阘闿阓阛腼霁雳霭靓飑飒飓飕飙齑于鞒鞑鞯韨鞴顸颀龛颃颌颉颏颒颋颕颔颚颙颛颡颟颢颥颦颞飐飔飖飗饤饦饳饸饹饻馂饾肴馃馉馎馌飨餍鸠鸢鸨鸩鸪鸫鸬鸲鸱鸶鸸鸷鸹鸺鸾鹁鹂鹄鹆鹇鹈鹉鹋鹌鹎鹑鹕鹗鹚鹛鹜鹞鹣鹦鹧鹨鹩鹪鹫鹬鹱鹭鹳驲骃骎骍骔骙骕骦骉鲠髅髌髋鬓郁魉魇鱽鱾鲀鲂鱿鲄麸鲅鲆鲌鲉鲧鲏鲇鲐鲋鲊鲒鲘鲕鲖鲔鲛鲑鲓鲪鳀鲝鲩鲨鲬鲻鲯鲭鲞鲷酰鹾鲴鲱鲵鲲鲳鲮鲰鲶鲺鲹鲫鳊鳈鲗鳂鲽鳇鳅鲾鳄鳆鳁鳒鳑鳋鲥鳏鳎鳐鳍鲢鳌鳓鳘鲦鲣鳗龀龃龅龆龇龈龉龊龌黾鼋鼍鲈鲎鲚鲟鲡鲼鳛鳔鳉鳙鳕鳟鳝鳜鲙鳣鳡鳢鲿鳠鹘黩黪鼹齄鸤鸰鸮鸴鸻鸼鹀鹐鹓鹍鹒鹙鹖鸧鹟鹠鹡鹢鹝鹥鹔鹯鹲鹴黡鼌龁龂飚村钜㖞㧑㧟㱮䁖䇲䌶䌷䌸䌹䌺䍁䞍䴓䴔䴕䴖䴗䴘䴙伣俫刹厐叁呐垅姹弑悮戯捝揾梿棁榅煴疭瞆祃窎筼肮蔂蕰訚迳酂钅锺霡飏饣鲃鳚余硷耻囱恶珐厩扦瓮嚣扎伫谘藁腌腭沓蚝籼糇隽线莅讬䜣铇眦碜碱';\n\nvar tradChars = '夢緣丟並採亂亙亞嚲來侖侶俁俠倀倆倉個們倫偉側偵偽傑傖傘備傭傳傴債傷傾僂僅僉僑僕僥僨僱價儀儂億當儈儉儐儔儕盡償優儲儷羅攢儺儻儼兇兌兒兗內兩冊塗凍凜瀆處凱憑別刪剗剄則剛剝剮剴創鏟劃劇劉劊劌劍劑勁動務勩勛勝勞勢績勱勵勸勻匭匯匱奩櫝區協卻厙廳廁厭廠厲厴參靉靆叢吳呂咼員唄唚嗊啢問啓啞銜囉嘽喚喪喬單喲嗆嗇嗎嗚嗩嗶嘆嘍嘔嘖嘗嘜嘩嘮嘯嘰嘵嘸噅噓噝噠噥噦噯噲噴噸嚀嚇嚌嚕嚙嚦嚨嚮嚳嚴嚶囀囁囅囈蘇囑國圇圍園圓圖團坰墶壋垵壩埡執堅堊堖堝階堯報場壪塊塋塏塒塢塤塵塹磚墊墜磽墮壇墳牆墾壓壘壙壚壞壟壢壯壼壺壽夠夾奐奧奪奮妝姍姦姪娛嫵婁婦婭嫿媧媯媼媽裊嫗嫻嬈嬋嬌嬙嬡嬤嬪嬰嬸懶孌孫學孿宮寢實寧審寫寬寵寶將專尋對導尷屓屆屍屜屢層屨屬岡嶨嶢峴島峽嶮崍崗崬崢崳嵐歲嶔嶁嶄嶇嶗嶠嶧嶴嶸嶺嶼巋巒巔巰巹帥師帳帶幀幃幗幘幟幣幫幬襴幹幾庫廎廂廈蔭廚廝廟廡廢廣廩廬弳張強彈彌彎彠彥彫徑從徠複徵徹恆悅悵悶悽惱惲惻愛愜愨愴愷愾態慍慘慚慟慣慪慫憖慮慳懾慶憂憊憐憒憚憤憫憮憲憶懇應懌懍懨懟懣懲懷懸懺懼歡戀戇戔戧戩戲戰戶拋掗撏挾捫掃掄掙掛揀揚換揮構撳損搖搗搶摑摜摟摯摳摶摻撈撐撓撟撣撥撫撲撻撾撿擁擄擇擊擋擔攜據擠舉擬擯擰擱擲擴擷擺擻擼擾攄攆攏攔攖攙攛攝攣攤攪攬敘敗敵數驅斂斃斕斬斷暘曨時晉晝暈暉暢暫暱曄曇曉曖曠曡曬書會朧東柵桿梔梘條梟檮棶棄棖棗棟棧棬棲椏楊楓楨業極榪榮榿盤槍槓檟槧槨槳規樁樂樅樓標樞樣樸樹樺橈橋機橢橫橰檁檉檔檜檢檣檳檸檻檾櫃櫓櫚櫛櫞櫟櫥櫧櫨櫪櫫櫬櫳櫸欞櫻欄權欏欒欖欽歐歟歸歿殘殞殤殫殮殯殲殺殼毀毆醫絨毿犛氈氌氣氫氬氳氹決沍沒沖渢濔況洩洶溮滻濜浹涇溳涼淚淥淨淩淪淵淶淺渙減渦測渾湊湞湣湧湯漊溈準溝溫濕滄滅滌滎澦滬滯滲鹵滸滾滿漁漚漢漣漬漲漵漸漿潁潑潔潛潤潯潰潷潿澀澆澇澗澠澤澩澮澱濁濃濘濟濤濫濰濱闊濺濼濾瀅瀉瀋瀏瀕瀘瀝瀟瀠瀦瀧瀨瀲瀾灃灄灑灕灘灝灣灤灧災為烏烴無煆輝煉煒煙煢煥煩煬熒熗熱熲熾燁燄燈燉燒燙燜營燦燭燴燻燼燾燿爍爐爛爭爺爾牀箋閘牘牽犖犢犧狀獮狹狽猙猶猻獁獃獄獅獎獨獪獫獰獲獵獷獸獺獻獼玀茲璵瑒玨瑲璫現璡琿瑉瑋瑣瑤瑩瑪璉璣璦環璽瓊瓏瓔瓚甌罌產畝畢畫異疇痙瘂瘮瘋瘍瘓瘞瘡瘧瘻療癆癇癉癘癟癡癢癤癥癧癩癬癭癮癰癱癲發皚皸皺藹礙襖罷頒辦絆綁鎊謗盜盞監盧蕩視矓眾睜飽鮑輩貝鋇繃筆閉邊編貶變辯辮鱉賓餅睞瞘瞞瞼矚缽鉑駁補財蠶蒼艙詫蟬饞讒纏闡顫矯硜磑礄硤硨硯磣長腸鈔車陳襯稱誠騁遲馳齒蟲躊籌綢醜鋤雛碩碭碸確碼磧磯礎觸闖錘純綽辭詞賜聰蔥躥竄錯達貸礦礪礫礬礱禕祿禍禎鄲膽誕黨禱鄧遞締顛點電釣調諜禦禪禮禰禿穠稅稈稜釘頂錠訂鬥讀賭鍍鍛緞隊頓鈍鵝額訛餓餌稟種穀穌積穎穡穢頹穩穭貳罰閥釩範販飯訪紡飛誹費紛糞豐鋒風馮縫諷鳳膚輻窩窪窮窯窶窺竅竇竊豎競輔賦負訃縛該鈣蓋趕贛鋼綱鎬鴿閣鉻給筍簹筧箏籙節龔鞏貢鉤購蠱顧關觀館貫龜閨軌詭貴輥鍋過築篋篠篤篩篳簀簍簑簞簡簣簫簷簽簾駭韓號閡鶴賀轟鴻紅後籃籐籜籟籠鑰籩籪籬籮籲粵護華話還緩黃謊賄諱誨繪葷夥貨糝糢糧糲糴糶糾紀紂約紆紇紈紉紋納紐紓紕紖紗紘紙級紜紝細紱紲紳紵饑跡譏雞緝輯薊計記際繼莢頰賈鉀駕間艱緘繭薦鑒踐賤見鍵紹紺紼紿絀終組絎結絕縧絝絞絡絢絰統絲絳絹綃綆綈繡綌綏經艦餞蔣講醬膠驕鉸腳餃繳轎較誡緊錦謹進綜綞綠綣綬維綯綰網綴綸綹綺綻綾綿緄緇緋緡緒緓緔緗緙緦緬緯緱緲練緶緹荊莖鯨驚頸靜鏡舊駒鋸鵑覺訣鈞軍縕總縈縉縊縋縐縑縗縝縞縟縣縭縮縱縲纖縵縶縷縹繅繆繈繒織繕繚駿開顆課褲誇虧繞繢繩韁繯繰繹繽繾纇纈纊續纓纘纜饋蠟臘萊賴藍闌蘭讕覽鐳類離鯉麗罵羆羈羋羥羨義習翽翬隸聯蓮連鐮臉鏈輛諒遼鐐臨鄰鱗賃齡鈴靈領餾龍聾翹翺耬耮聖聞聲聳聵聶職聹聽隴蘆顱虜魯賂錄陸驢鋁輪論蘿邏鑼騾駱螞馬買麥賣邁脈饅蠻肅脅脛脫脹謾貓錨鉚貿麼鎂門錳謎覓閩鳴銘謬腎腖膕腡腦腫膁膃膩膾膿臍臏臒謀鈉難鬧餒釀鳥鑷鎳臚臢髒臠臥臯與興鋪艤鈕農諾鷗龐賠鵬艫艷艸芻苧騙飄頻貧蘋評頗譜齊騎豈訖薘莊莧釺鉛遷謙錢鉗譴薔鍬親輕頃請趨軀萇蘀萬萵葉葒葤葦藥齲顴鵲讓饒韌認軟銳閏薩鰓賽蒓蒔蓀蓧蓯蓽騷閃陝贍賞賒設蔞蔦蕁蕆蕎蕒蕓蕕蕘蕢蕪蕭蕷詩蝕識駛適釋飾試輸贖術薈薌薑薟薺藎藝藪藶雙誰順說飼頌訟誦訴雖隨鎖藺蘄蘊蘚蘞蘢蘺虛貪譚談討騰謄銻題體貼鐵蛺蛻蜆銅頭鴕馱駝襪頑蝟蝦蝨蝸螿螄蟻螢韋違謂衛鎢誣霧誤錫螻蟄蟈蟎蠨蟣蟯蟶蠅蠆蠍蠐蠑蠣襲銑轄鍁鮮鹹賢閑顯險餡鑲鄉詳響項銷衊褘袞諧謝鋅釁鏽須許軒襏褌裝褳選詢馴訓訊遜鴉鴨訝閹鹽顏閻諺驗鴦陽養褸褻襆襇雜襝襠襤覎覘覡遙謠頁銥頤遺詣議誼譯陰銀飲隱覥覦覬覯覷覲覿觴觶訁訌訐訒訕鷹贏踴詠郵鈾誘輿魚語譽訥諶訩訶診註證詁詆詎詐詒詔詖詗詘詛讋詡詬詮詰詵詼詿預馭鴛轅遠願躍閱雲鄖隕運醞韻載贊贓鑿責賊贈軋誄誅誆誑誒誚誥誶諂諄諉諍諏諑諗諛諝諞諡諢鍘齋輾賬趙轍鍺這貞針鎮陣諤諦諫諭諳諸諼謁謅謐謔謖謨謫謳鄭質鐘軸驟豬著貯鑄譎譖譙譫譸譾讎讖讜讞駐轉賺錐贅資蹤鄒鑽豶貍貟鞀靨贗賾貰貲貺貽賁賅賑賕賙賚賡賧賫贐賵賻贄贇黌鳧贔赬趲陘隉鄺鄔鄴躂踡蹌蹕蹠蹣郟鄶郤鄆酈蹺躉躋躑躒躓躕躚躡躦躪軑軔軛軤軫軲軹軺軻軼軾輅輇輈輊輒輜輞輟輦輬輳轀轂鶯驀鎣轆轔轡轢轤邇邐醱釃釅釓釔釕釗釙釤麅釧釵釷釹鈀鈁鈃鈄鈈鈐鈑鈒鈥鈦鈧鈮鈰鈳鈷鈸鈹鈺鈽鈿餳飩餼飪飫飭飴餉餑餘餛餷餿饃饈饉饊饌饢鉈鉉鉍鉕鉞鉦鉬鉭鐦鉶鉺鉿銃銍銓銖銚銛銠銣銦閂閆闈閎閔閌闥閭閫鬮閬閾閶鬩閿閽閼闃闋闔闐闕闞爿銨銩銪銫銬銱銼鎇鋃鋌鋏鋙鐲鋝鋟鋣鋥鋦鋨鋩鋮鋯鋰鋱鋶錁錆錇錈錏錒錕錙錚錛錟錡錩錮錸鎿鍀鍃鍆鍇鍈鍔鍚鍠鍤鍥鍩騫鍰鍶鎄鎔鎘鎛鎡鎦鎧鎩鎪鎰鎲鎵鐫鏃鏇鏌鏍駔駟駙騶驛駑駘驍驊駢驪騏騍騅驂騭騖驁騮騸驃驄驏驥驤糸鏐鏑鏗鏘鏜鏝鏞鏢鏤鏨鏰鏵鏷鏹鐃鐋鐒鐓鐔鐙钁鐠鐧鐨頊鐶鐸鐺鐿鑊鑌鑔鑕鑞鑠鑣鑥鑭鑱鑹鑾韙韞韜閈闍闒闓闠闤靦霽靂靄靚颮颯颶颼飆齏於鞽韃韉韍韝頇頎龕頏頜頡頦頮頲頴頷顎顒顓顙顢顥顬顰顳颭颸颻飀飣飥飿餄餎餏餕餖餚餜餶餺饁饗饜鳩鳶鴇鴆鴣鶇鸕鴝鴟鷥鴯鷙鴰鵂鸞鵓鸝鵠鵒鷳鵜鵡鶓鵪鵯鶉鶘鶚鶿鶥鶩鷂鶼鸚鷓鷚鷯鷦鷲鷸鸌鷺鸛馹駰駸騂騌騤驌驦驫鯁髏髕髖鬢鬱魎魘魛魢魨魴魷魺麩鮁鮃鮊鮋鯀鮍鮎鮐鮒鮓鮚鮜鮞鮦鮪鮫鮭鮳鮶鯷鮺鯇鯊鯒鯔鯕鯖鯗鯛醯鹺鯝鯡鯢鯤鯧鯪鯫鯰鯴鰺鯽鯿鰁鰂鰃鰈鰉鰍鰏鱷鰒鰮鰜鰟鰠鰣鰥鰨鰩鰭鰱鰲鰳鰵鰷鰹鰻齔齟齙齠齜齦齬齪齷黽黿鼉鱸鱟鱭鱘鱺鱝鰼鰾鱂鱅鱈鱒鱔鱖鱠鱣鱤鱧鱨鱯鶻黷黲鼴齇鳲鴒鴞鴬鴴鵃鵐鵮鵷鵾鶊鶖鶡鶬鶲鶹鶺鷁鷊鷖鷫鸇鸏鸘黶鼂齕齗飈邨鉅喎撝擓殨瞜筴䊷紬縳絅䋙繸䝼鳾鵁鴷鶄鶪鷈鷿俔倈剎龎叄吶壠奼弒悞戱挩搵槤梲榲熅瘲瞶禡窵篔骯虆薀誾逕酇釒鍾霢颺飠䰾䲁餘礆恥囪惡琺廄扡甕囂紮佇諮槁醃齶遝蠔秈餱雋線蒞託訢鉋眥磣鹼';\n\nvar charactersNoDef = [];\n\nfor (var i = 0; i < simpChars.length; i++) {\n  charactersNoDef.push(simpChars.charAt(i)+'|'+tradChars.charAt(i));\n}\n\nvar charactersWithDef = `本|本\n茶|茶|Tea\n书|書\n書|書\n個|個\n块|塊\n塊|塊\n張|張\n華|華\n家人|家人|Family|noun\n不客气|不客氣|You are welcome|expression\n不客氣|不客氣|You are welcome|expression\n謝謝|謝謝|Thank you|expression\n谢谢|謝謝|Thank you|expression\n谢|謝|Thank|verb|Can be doubled to say 谢谢 (Thank you)\n謝|謝|Thank|verb|Can be doubled to say 謝謝 (Thank you)\n伦敦|倫敦|London|City\n倫敦|倫敦|London|City\n台灣|台灣|Taiwan|Country\n台湾|台灣|Taiwan|Country\n哪儿|哪兒|Where|interrogative adverb\n纽约|紐約|New York|City\n香港|香港|Hong Kong|City\n你好|你好|Hello|greeting|literally: 'you good'?\n高|高|High/Tall|adjective\n兴|興|Happy|adjective\n很|很|Very|adverb\n识|識|Knowledge|noun\n认|認|Recognise|verb\n也|也|Also|adverb\n我|我|I|pronoun\n他|他|He|pronoun\n好|好|Good|adjective\n学|學|Understand/Learn|noun/verb|Forms a compound word 学生(student)\n你|你|You|pronoun|literally: 'you good'?\n興|興|Happy|adjective\n識|識|Knowledge|noun\n認|認|Recognise|verb\n李|李|Li|surname\n姓|姓|surname|noun\n九|九|Nine|number\n零|零|Zero|number\n百|百|100|number\n三|三|Three|number\n字|字|Word|noun\n再|再|Again|adverb|Forms a compound word 再見 (Goodbye, literally again see).\n二|二|Two|number\n一|一|One|number\n五|五|Five|number\n十|十|Ten|number|Can be combined with other numbers to create multiples of ten 七十 (Seventy)\n六|六|Six|number\n叫|叫|Call|verb\n鱼|魚|Fish|noun\n喝|喝|Drink|verb\n饭|飯|Rice|noun|\n面|面|Noodles|noun\n吃|吃|Eat|verb\n水|水|Water|noun\n茶|茶|Tea|noun\n魚|魚|Fish|noun\n不|不|No/Not|Determiner/Adverb\n飯|飯|Rice|noun|\n么|麼|Interrogative sentence|suffix|什么(What), 怎么 (How), 这么 (Like this), 多么 (how; what; so; such)\n七|七|Seven|number\n呢|呢|Interrogative particle|suffix\n麼|麼|Interrogative particle|suffix|什么(What), 怎么 (How), 这么 (Like this), 多么 (how; what; so; such)\n名|名|Name|noun\n王|王|Wang|name\n见|見|See|verb|Forms a compound word 再見 (Goodbye, literally again see).\n見|見|See|Verb|Forms a compound word 再見 (Goodbye, literally again see).\n她|她|She/Her|pronoun\n们|們|Plural|suffix|Turns 她 (she) into them/they plural (females) 她们 or 他 (he) into them/they 他們 (males)\n是|是|Be|verb\n吗|嗎|Interrogative particle|suffix|At the end of a sentence it creates a yes/no question.\n生|生|Pupil|noun|forms a compound word 學生(student)|This word has a lot of meanings; live, grow, pupil, disciple.\n师|師|Expert|noun|orms a compound word 老師 (teacher)\n們|們|Plural|suffix|Turns 她 (she) into them/they plural (females) 她们 or 他 (he) into them/they 他們 (males)\n老|老|Experienced|noun/verb|forms a compound word 老師 (teacher)\n医|醫|Doctor/medicine|noun|forms a compound word 醫生  (doctor)|This word has a lot of meanings; live, grow, pupil, disciple.\n嗎|嗎|Interrogative particle|suffix|At the end of a sentence it creates a yes/no question.\n師|師|Expert|noun|forms a compound word 老師 (teacher)\n醫|醫|Doctor/medicine|noun|forms a compound word 醫醫生  (doctor)|This word has a lot of meanings; live, grow, pupil, disciple.\n起司|起司\n媽|媽|Mum|particle noun|doubles to make 媽媽(Mum)\n妈|媽|Mum|particle noun|doubles to make 妈(Mum)\n脏|臟\nundefined|undefined\n轻|輕|Light/Small|adjective\n麵|麵|Noodles|noun\n节|節\n国|國|Country|noun\n法|法\n力|力\n后|後\n利|利\n想|想\n國|國|Country|noun\n後|後\n努|努\n季|季\n还|還\n最|最\n大|大|Large|Adjective|Can also be used in a compound to form the word 加拿大 (Canada)\n白|白\n酒|酒\n望|望\n意|意\n失|失\n節|節\n還|還\n点|點\n點|點\n儿|兒|Child|noun\n兒|兒|Child|noun\n的|的|his/her/my/your|posessive suffix|Used after a word it indicates the belonging of; for example combining 我 (I) making a 我的(my) or 他 (he) making 他的(his)\n八|八|Eight|number\n次|次\n元|元|Yen|Noun|Currency of Mainland China 🇨🇳\n四|四|Four|number\n张|張\n明|明\n您|您\n华|華\n什|甚|What|interrogative adverb\n其|其\n人|人|Person|noun|You will almost always see this in a compound word like 中国人 (Chinese person; literally China person).\n天|天|Day|noun|Can be combined with 今 (now) to make the compound word 今天(today).\n地|地\n火|火\n理|理\n课|課\n锅|鍋\n小|小|Small|adjective\n个|個\n有|有\n鍋|鍋\n課|課\n馆|館\n啡|啡\n咖|咖\n图|圖\n下|下\n館|館\n圖|圖\n戴|戴\n甜|甜\n美|美|Beautiful/America|Verb/Noun|This can form a compound word with 国 (country) to make 美国 (America) or 美国人 (American person; literally America man)\n术|術\n爷|爺\n術|術\n爺|爺\n过|過\n過|過\n油|油\n条|條\n條|條\n京|京|Commonly used with 北 (North) to make 北京(Beijing. Literally: North capital)\n秋|秋\n年|年\n去|去\n来|來\n北|北|North|noun|Commonly used with 京 (Capital) to make 北京(Beijing. Literally: North capital)\n了|了|Adverb|Indicates something is complete or finished\n來|來\n信|信\n应|應\n心|心|Heart|noun\n该|該\n該|該\n應|應\n赛|賽\n在|在|In|Preposition\n每|每\n要|要\n比|比\n月|月\n现|現\n练|練\n习|習\n賽|賽\n現|現\n練|練\n習|習\n错|錯\n考|考\n试|試\n得|得\n試|試\n錯|錯\n泰|泰\n彡|彡\n雨|雨\n勇|勇\n安|安\n羅|羅\n唐|唐\n智|智\n骏|駿\n劉|劉\n斌|斌\n哲|哲\n朝|朝\n扬|揚\n瑞|瑞\n路|路\n欣|欣\n駿|駿\n揚|揚\n昂|昂\n納|納\n多|多|Many|Compound: Determiner, pronoun and adjective|Can form compound question endings such as 多少 (what is?)\n萊|萊\n且|且\n而|而\n妳|妳|You(Female)|pronoun\n米|米\n期|期|Meet|verb\n星|星\n日|日|Sun/Day|noun\n周|週\n週|週\n英|英|Excellent/British|noun/adjective|This can form a compound word with 国 (country) to make 英国 (Britain) or 英国人 (British person; literally Britain country man)\n語|語\n動|動\n詞|詞\n置|置\n物|物\n間|間\n付|付\n家|家|Family|noun\n族|族\n前|前\n副|副\n時|時\n業|業\n容|容\n職|職\n形|形\n治|治\n場|場\n回|回\n所|所\n身|身\n数|數\n政|政\n属|屬\n性|性\n數|數\n屬|屬\n板|板\n中|中|Middle|adjective|You will mostly see this character as a compound with 国 (country) making 中国 (China)\n編|編\n集|集\n掲|掲\n示|示\n問|問\n言|言\n題|題\n作|作\n探|探\n成|成\n決|決\n覧|覧\n解|解\n貢|貢\n対|対\n応|応\n献|獻\n投|投\n新|新\n気|気\n稿|稿\n規|規\n着|著\n章|章\n文|文|Language|noun\n歴|歴|Experience|verb\n代|代\n索|索|Search|verb\n検|檢\n結|結\n果|果|Fruit|noun\n入|入\n先|先\n内|內\n以|以\n収|収\n概|概\n求|求\n約|約|noun|Commonly used with 约 to form 纽约(New York)\n情|情\n報|報\n護|護\n保|保\n確|確\n用|用|Use|Verb\n送|送\n受|受\n必|必\n箱|箱\n説|説\n管|管\n閉|閉\n獻|獻\n著|著\n內|內\n化|化\n強|強|Strong|adjective\n記|記|Remember|verb\n憶|憶|Memory|noun\n復|復\n校|校\n外|外\n喜|喜\n音|音\n听|聽\n欢|歡\n韩|韓\n乐|樂\n聽|聽\n歡|歡\n韓|韓\n樂|樂\n行|行\n食|食\n級|級\n飛|飛\n版|版\n通|通\n影|影\n视|視\n上|上|up; on; on top|preposition|Can be used with the word 早 to make 早上 (morning). Literally: \"upon (the time when it is) early\".\n网|網\n手|手\n干|幹\n报|報\n机|機|Machine|noun\n电|電|Electricity|noun|Can form a compound word to form 电话 (telephone)\n纸|紙|Paper|noun\n闻|聞\n体|體\n育|育\n目|目\n哪|哪|Which/Where|Interrogative particle\n里|裡\n班|班|Class|noun\n汉|漢\n哥|哥\n语|語|Language|noun\n視|視|Visual|noun\n網|網|Network|noun\n幹|幹|Do|verb\n機|機|Machine|noun\n電|電|Electricity|noun|Can form a compound word to form 电话 (telephone)\n紙|紙\n聞|聞\n體|體\n裡|裡\n漢|漢\n票|票\n远|遠\n办|辦\n走|走\n靠|靠\n到|到\n近|近|Near|adjective\n迟|遲|Late|adjective\n怎|怎|How|interrogative\n车|車|Car|noun\n从|從|From|preposition\n店|店|Shop|Noun\n港|港|Harbour|Noun|Commonly used with 香 (Fragrant) to form 香港 (Hong Kong. Literally: fragrant harbour)\n开|開|Open|Verb\n飞|飛|Fly|Verb\n敦|敦|Honest|adjective|Commonly used with 伦 to form 伦敦 (London)\n让|讓\n非|非\n伦|倫|relationship|noun|Commonly used with 敦 to form 伦敦 (London)\n场|場\n停|停|Stop|verb\n离|離|Leave|verb\n香|香|Fragrant|adjective|Commonly used with 港 (Harbour) to form 香港 (Hong Kong. Literally: fragrant harbour)\n太|太\n常|常\n遠|遠\n辦|辦\n遲|遲\n車|車\n從|從\n開|開\n倫|倫|relationship|noun|Commonly used with 敦 to form 伦敦 (London)\n讓|讓\n離|離\n但|但\n然|然\n长|長\n短|短\n虽|雖\n颜|顏\n红|紅\n色|色\n穿|穿\n洗|洗\n黄|黃\n表|表\n卖|賣\n黃|黃\n子|子\n紫|紫|Purple|noun\n帽|帽\n会|會\n今|今|Now|Adverb|Can be combined with 天 (day) to make the compound word 今天(today)\n饱|飽\n長|長\n雖|雖\n顏|顏\n紅|紅\n賣|賣\n會|會\n飽|飽\n定|定\n可|可\n请|請\n跟|跟\n起|起\n請|請\n买|買\n買|買\n这|這|This|pronoun\n這|這|This|pronoun\n贵|貴\n貴|貴\n汽|汽\n边|邊\n右|右\n邊|邊\n又|又\n写|寫\n台|台|Station|noun|Commonly used with 湾 to form 台湾(Taiwan)\n寫|寫|Write|verb\n牙|牙\n拍|拍\n睛|睛\n司|司\n公|公\n假|假\n晚|晚\n几|幾\n致|致\n做|做\n幾|幾\n已|已\n经|經\n經|經\n剛|剛\n沒|沒\n辛|辛\n苦|苦\n謝|謝|Thank|verb|Can be doubled to say 謝謝 (Thank you)\n幫|幫\n使|使\n键|鍵\n鍵|鍵\n能|能\n歌|歌\n看|看\n唱|唱\n跳|跳\n舞|舞\n式|式\n爱|愛|Love|noun\n爱|愛|Love|noun\n谁|誰|Who|pronoun\n像|像\n那|那|That|pronoun\n些|些\n誰|誰|Who|pronoun\n共|共\n女|女\n朋|朋\n亮|亮\n友|友\n漂|漂\n游|遊\n遊|遊\n爸|爸|Dad|particle noun|doubles to make 爸爸(Dad)\n住|住|live|verb\n拿|拿|take|verb|Can also be used in a compound to form the word 加拿大 (Canada)\n约|約|approximately|adjective|Commonly used with 约 to form 纽约(New York)\n湾|灣|Bay|noun|Commonly used with 台 to form 台湾(Taiwan)\n灣|灣|Bay|noun|Commonly used with 台 to form 台灣(Taiwan)\n午|午\n乹|乹\n乾|乾\n亁|亁\n都|都|All/Both|Predeterminer, determiner and pronoun\n观|觀\n觀|觀\n末|末\n夫|夫\n聲|聲\n声|聲\n思|思\n掉|掉\n给|給\n只|只\n问|問\n量|量\n種|種\n匹|匹\n工|工\n給|給\n杯|杯\n奶|奶\n牛|牛\n搬|搬\n算|算\n打|打\n突|突\n重|重\n议|議\n房|房\n间|間\n放|放\n把|把\n进|進\n菜|菜\n冬|冬\n没|沒\n男|男\n差|差\n刻|刻\n笑|笑\n别|別\n辆|輛\n租|租\n出|出\n照|照\n感|感\n冒|冒\n臟|臟\n議|議\n進|進\n別|別\n輛|輛\n号|號|Name|noun|Can form compounds such as 码号 (names of numbers)\n號|號|Name|noun|Can form compounds such as 码号 (names of numbers)\n关|關\n關|關\n码|碼|Number/Numeric|noun/verb|Can form compounds such as 码号 (names of numbers) and 电话码 (telephone number)\n少|少\n碼|碼|Number/Numeric|noun/verb|Can form compounds such as 码号 (names of numbers) and 电话码 (telephone number)\n玩|玩\n戏|戲\n戲|戲\n左|左\n道|道\n分|分\n知|知\n读|讀\n阅|閱\n消|消\n息|息\n运|運\n动|動\n讀|讀\n閱|閱\n運|運\n臺|臺\n骨|骨\n套|套\n眼|眼\n疆|疆\n加|加|Add|noun|Can also be used in a compound to form the word 加拿大 (Canada)\n坡|坡\n对|對|Correct|adjective\n决|決\n對|對|Correct|adjective\n绿|綠\n姐|姐\n发|發\n懂|懂\n猫|貓\n熊|熊\n头|頭\n饼|餅\n完|完\n转|轉\n谢|謝|謝|Thank|verb|Can be doubled to say 谢谢 (Thank you)\n啊|啊\n包|包\n需|需\n药|藥\n院|院\n净|淨\n猪|豬\n肉|肉\n急|急\n綠|綠\n發|發\n貓|貓\n轉|轉\n藥|藥\n淨|淨\n豬|豬\n室|室\n教|教\n同|同\n题|題\n笔|筆\n准|準\n科|科\n备|備\n话|話|Speak/Language|verb/noun|Can form a compound word to form 电话 (telephone)\n筆|筆\n準|準\n備|備\n話|話|Speak/Language|verb/noun|Can form a compound word to form 电话 (telephone)\n旁|旁\n快|快\n希|希\n堂|堂\n叉|叉\n漫|漫\n扰|擾\n擾|擾\n和|和\n頭|頭\n始|始\n早|早|Early|adjective|Can be used with the character 上 to form the compound word 早上 (morning)\n睡|睡\n床|床\n觉|覺\n覺|覺\n找|找\n忙|忙|Busy|adjective\n样|樣\n樣|樣\n甚|甚|What|interrogative adverb\n蛋|蛋\n碗|碗\n嚿|嚿\n炒|炒\n頓|頓\n柒|柒\n纽|紐|Button|noun|Commonly used with 约 to form 纽约(New York)\n紐|紐|Button|noun|Commonly used with 约 to form 纽约(New York)\n惇|惇\n枝|枝\n客|客|Guest|noun|Commonly used with 气 to form 客气(polite) or 不客气(You're welcome, literally:  don't be so polite)\n气|氣|Air|noun|Commonly used with 客 to form 客气(polite) or 不客气(You're welcome, literally:  don't be so polite)\n系|系\n氣|氣|Air|noun|Commonly used with 客 to form 客气(polite) or 不客气(You're welcome, literally:  don't be so polite)\n迎|迎\n博|博\n憾|憾\n遗|遺\n遺|遺\n係|係\n繫|繫\n抱|抱\n歉|歉\n弟|弟\n妹|妹\n两|兩\n弟|弟\n兩|兩\n更|更\n旧|舊\n舊|舊\n助|助\n助|助\n帮|幫\n帮|幫\n说|說\n說|說\n提|提\n悌|悌\n托|托\n越|越\n时|時\n拜|拜\n遍|遍\n兄|兄\n輕|輕\n讲|講\n講|講\n久|久\n愿|願\n願|願\n夜|夜\n段|段\n热|熱\n冰|冰\n熱|熱\n结|結\n构|構\n连|連\n構|構\n連|連\n饮|飲\n料|料\n飲|飲\n隻|隻\n姊|姊\n半|半\n孩|孩\n岁|歲\n歲|歲\n狗|狗\n妻|妻\n丈|丈\n位|位\n等|等\n爵|爵\n斤|斤\n瓶|瓶\n慢|慢\n喂|餵\n餵|餵\n矮|矮\n昨|昨\n诉|訴\n告|告\n苹|蘋\n业|業\n訴|訴\n蘋|蘋\n往|往\n坐|坐\n脑|腦\n腦|腦\n伞|傘\n宜|宜\n便|便\n傘|傘\n裤|褲\n褲|褲\n为|為\n为|為\n為|為\n订|訂\n舒|舒\n訂|訂\n空|空\n留|留\n骑|騎\n超|超\n騎|騎\n病|病\n病|病\n病|病\n累|累\n休|休\n豆|豆\n拉|拉\n浆|漿\n粥|粥\n拉|拉\n笼|籠\n漿|漿\n籠|籠\n金|金\n卡|卡\n钱|錢\n毛|毛\n千|千\n收|收\n万|萬\n萬|萬\n錢|錢`.split('\\n');\n\nexport const characters = charactersNoDef.concat(charactersWithDef);\n\nexport const charactersVersion = 303;\n","import { characters, charactersVersion } from './characters.js';\n\nexport class Cache{\n   static setCharacter(simplifiedCharacter, realCharacter){\n     localStorage.setItem(simplifiedCharacter, realCharacter);\n   }\n  static updateLocalStorage(){\n\n    if (localStorage.getItem('version') == null || parseFloat(localStorage.getItem('version')) < charactersVersion){\n      localStorage.clear();\n      console.log('clear cache');\n      localStorage.setItem('version', charactersVersion);\n      characters.forEach((x) => {\n        let [simplified, traditional] = x.split('|');\n        localStorage.setItem(simplified, traditional);\n      });\n    }\n  }\n}\n","import { characters } from './characters.js';\nexport class CharacterLookup{\n      constructor(){\n        this.dictionary={};\n        for(let x in characters){\n            let [simplified, traditional, meaning, type, explaination] = characters[x].split('|');\n            this.dictionary[simplified] = {meaning: meaning, type:type, explaination: explaination};\n            this.dictionary[traditional]  = {meaning:meaning, type: type, explaination : explaination};\n        }\n      }\n\n      getMeaning(character){\n      \n          return this.dictionary[character];\n      }\n}\n","/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\n// EXPOSE\nvar _sizzle = window.Sizzle;\n\nSizzle.noConflict = function() {\n\tif ( window.Sizzle === Sizzle ) {\n\t\twindow.Sizzle = _sizzle;\n\t}\n\n\treturn Sizzle;\n};\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine(function() { return Sizzle; });\n// Sizzle requires that there be a global window in Common-JS like environments\n} else if ( typeof module !== \"undefined\" && module.exports ) {\n\tmodule.exports = Sizzle;\n} else {\n\twindow.Sizzle = Sizzle;\n}\n// EXPOSE\n\n})( window );\n","import { characters } from \"./characters.js\";\nimport { CharacterLookup } from \"./characterLookup.js\";\nimport Sizzle from \"sizzle\";\nlet characterLookup = new CharacterLookup();\n\nconst configuration = {};\n\nfunction settingsChanged() {\n  if (configuration[\"meanings\"] == true) {\n    document.body.classList.add(\"show-meanings\");\n  } else {\n    document.body.classList.remove(\"show-meanings\");\n  }\n}\n\nchrome.storage.sync.get(\"traditional\", function(result) {\n  configuration[\"traditional\"] = result.traditional;\n  settingsChanged();\n});\n\nchrome.storage.sync.get(\"meanings\", function(result) {\n  configuration[\"meanings\"] = result.meanings;\n  settingsChanged();\n});\n\nchrome.storage.onChanged.addListener(function(changes) {\n  configuration[Object.keys(changes)[0]] =\n    changes[Object.keys(changes)[0]].newValue;\n  settingsChanged();\n});\n\nexport class Duolingo {\n  static isLearningChinese() {\n    const state = JSON.parse(localStorage.getItem(\"duo.state\"));\n\n    return state.user.courseId.match(/ZH\\-CN_EN/i) != null;\n  }\n  static insertCharacter(maoCharacacter, realCharacter) {\n    let character = realCharacter;\n    setTimeout(function() {\n      let singleChalengeElement = document.querySelector(\n        '[data-test=\"challenge-header\"] + span > div > div'\n      );\n      if (singleChalengeElement !== null) {\n        if (singleChalengeElement.childElementCount == 2) {\n          const meaning = characterLookup.getMeaning(character);\n          if (meaning !== undefined) {\n            const div = document.createElement(\"div\");\n            const explaination =\n              meaning.explaination == undefined ? \" \" : meaning.explaination;\n            const type = meaning.type == undefined ? \" \" : meaning.type;\n            const englishTranslation =\n              meaning.meaning == undefined ? \" \" : meaning.meaning;\n            div.innerHTML = `<div class=\"meaning\"><div class=\"english\">${englishTranslation}</div><div class=\"type\">${type}</div><div class=\"explaination\">${explaination}</div></div>`;\n            singleChalengeElement.appendChild(div);\n          }\n        }\n      } else {\n      }\n    }, 500);\n    if (configuration[\"traditional\"] == false) {\n      return;\n    }\n    if (maoCharacacter == realCharacter) {\n      return;\n    }\n    if (maoCharacacter == undefined || maoCharacacter == \"undefined\") {\n      return;\n    }\n\n    const element = Sizzle(`:contains(${maoCharacacter})`).slice(-1)[0];\n\n    if (element) {\n      element.innerHTML = element.innerHTML.replace(\n        maoCharacacter,\n        realCharacter\n      );\n    }\n  }\n\n  static checkForChineseCharactersOnLoad() {\n    if (Duolingo.isLearningChinese() == false) {\n      return;\n    }\n    setTimeout(function() {\n      characters.forEach((x, y) => {\n        let [simplified, traditional] = x.split(\"|\");\n        setTimeout(function() {\n          const element = Sizzle(`:contains('${simplified}')`);\n          if (element.length != 0) {\n            Duolingo.insertCharacter(simplified, traditional);\n          }\n        }, 10);\n      });\n    }, 1000);\n  }\n}\n","import { Duolingo } from \"./duolingo.js\";\nimport { Cache } from \"./cache.js\";\nimport { CharacterLookup } from \"./characterLookup.js\";\n\nlet characterLookup = new CharacterLookup();\n\nexport const mutationObserver = new MutationObserver(function(mutations) {\n  if (Duolingo.isLearningChinese() == false) {\n    return false;\n  }\n\n  for (let i = 0; i < mutations.length; i++) {\n    for (let j = 0; j < mutations[i].addedNodes.length; j++) {\n      const node = mutations[i].addedNodes[j];\n      const nodeSting = node.textContent;\n      const asciiStringArray = nodeSting.replace(/[^\\x00-\\x7F]/g, \"\");\n      if (nodeSting.match(/[\\u3400-\\u9FBF]/)) {\n        let difference = nodeSting\n          .split(\"\")\n          .filter(x => asciiStringArray.indexOf(x) == -1);\n\n        if (difference.length == 0) {\n          return;\n        }\n        const chineseCharacters = [];\n        const compoundChineseCharacters = [];\n        let lastCharacterChinese = false;\n        let lastCharacter = \"\";\n        difference.forEach(character => {\n          if (character > \"\\u3400\" && character < \"\\u9FBF\") {\n            chineseCharacters.push(character);\n            lastCharacterChinese = true;\n\n            if (lastCharacter != \"\" && lastCharacterChinese == true) {\n              compoundChineseCharacters.push(lastCharacter + character);\n            }\n            lastCharacter = character;\n          } else {\n            lastCharacterChinese = false;\n            lastCharacter = \"\";\n          }\n        });\n\n        compoundChineseCharacters.forEach(compoundCharacter => {\n          const result = characterLookup.getMeaning(compoundCharacter);\n          if (result) {\n            chineseCharacters.unshift(compoundCharacter);\n          }\n        });\n\n        chineseCharacters.forEach(character => {\n          if (localStorage.getItem(character) !== null) {\n            if (localStorage.getItem(character) != undefined) {\n              Duolingo.insertCharacter(\n                character,\n                localStorage.getItem(character)\n              );\n            }\n            return null;\n          }\n\n          const characterEncoded = encodeURI(character);\n\n          let reqListener = data => {\n            if (!mutations[i].addedNodes[j].innerHTML) {\n              return;\n            }\n            if (data.currentTarget.responseText) {\n              Cache.setCharacter(character, data.currentTarget.responseText);\n            }\n            //  Duolingo.insertCharacter(character, data.currentTarget.responseText)\n          };\n          if (navigator.onLine) {\n            // let oReq = new XMLHttpRequest();\n            // oReq.addEventListener(\"load\", reqListener);\n            // oReq.open(\n            //   \"GET\",\n            //   \"https://lookup.duochinese.space/?character=\" + characterEncoded\n            // );\n            // oReq.send();\n          }\n        });\n      }\n    }\n  }\n});\n","import { Cache } from './cache.js'\nimport { mutationObserver } from './mutationObserver.js';\nimport { characters } from './characters.js';\nimport { Duolingo } from './duolingo.js';\n\nCache.updateLocalStorage();\n\nDuolingo.checkForChineseCharactersOnLoad();\n\nmutationObserver.observe(document, {\n  childList: true,\n  subtree: true,\n  characterData: true\n});\n"]}